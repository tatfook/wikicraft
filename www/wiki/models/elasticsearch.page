<?npl
--[[
Title: elasticsearch
Author: Zheng Jiabiao
Date: 2018/1
Desc:Functions used to operate elasticsearch in port 9200
]]


include_once("./abstract/base.page")
local elasticsearch = inherit(models.abstract.base, gettable("models.elasticsearch"))


-- set host,port and index
function elasticsearch:connect(params)
    local params = params or {}
    local es_setting = KEEPWORK["config"][ENV_NAME]["wiki"]["es_setting"] or {}
    self.host = params.host or es_setting["host"] or "localhost"
    self.port = params.port or es_setting["port"] or 9200
    self.index = params.index or es_setting["index"]
    self.enabled = params.enabled or es_setting["enabled"] or 1
    self.url = format("http://%s:%d/%s/", self.host, self.port, self.index)
end


-- locate indices，types and generate url
function elasticsearch:locator(params)
    local _type = ""
    local _id = ""

    if (not self.url) then
        error("ES NOT CONNECTED, PLEASE CALL elasticsearch:connect")
    end

    if params.id then
        _id = params.id .. "/"
    end

    if params.type then
        _type = params.type .. "/"
    else
        _id = ""
    end

    params.type = nil
    params.id = nil

    return format("%s%s%s", self.url, _type, _id)
end


function elasticsearch:insertOne(params)
    if (not params.type) then
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    local location = self:locator(params)
    local insert_to = location
    params.type = nil

    -- 发送请求
    return self:sendToES({send_to=insert_to, method="POST", form=params})
end


function elasticsearch:updateOne(params)
    if (not params.type) or (not params.id) then
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    local location = self:locator(params)
    local update_to = location .. "_update"
    params.type = nil
    params.id = nil

    local body = {doc = params}
    return self:sendToES({send_to=update_to, method="POST", form=body})
end


-- can only find by single field(like id or any other keyword field)
function elasticsearch:findOne(params)
    local term = {_id = params.id}
    params.id = nil

    local location = self:locator(params)
    local search_in = location.. "_search"
    params.type = nil

    for k, v in pairs(params) do
        if (not term._id) then term[format("%s.keyword", k)] = v end
    end

    local body = {
        query = {
            constant_score = { 
                filter = {
                    term = term
                }
            }
        }
    }

    return self:sendToES({send_to=search_in, method="GET", form=body})
end


-- can only find by id
function elasticsearch:deleteOne(params)
    if (not params.type) or (not params.id) then
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    local location = self:locator(params)

    return self:sendToES({send_to=location, method="DELETE"})
end


function elasticsearch:search(params)
    local location = self:locator(params)
    local search_in = location .. "_search"
    local body = {}
    body = self:query_generator(params)

    -- highlight
    if (params.highlight == 1) then
        body.highlight = {fields = self:highlight_fields_generator(params)}
    end

    -- sort
    if params.sort then
        body.sort = params.sort      -- array
    end

    -- pagination
    body.size = params.size
    body.from = params.from

    return self:sendToES({send_to=search_in, method="GET", form=body})
end


function elasticsearch:query_generator(params)
    local query = {}

    -- 单字段搜索
    if (#params.fields == 1) then
        local match = {}
        match[params.fields[1]] = params.q
        query = {match = match}

    -- 多字段搜索
    elseif (#params.fields > 1) then
        query = {
        multi_match = {
            query = params.q,   --string
            fields = params.fields   --array
            }
        }
    end

    return {query=query}
end


function elasticsearch:highlight_fields_generator(params)
    local highlight_fields = {}

    for i, field in ipairs(params.fields) do
        highlight_fields[field] = {}
    end

    return highlight_fields
end


function elasticsearch:bulk(params)
    if (not params.data) then
        params.flag = "elasticsearch:bulk"
        log(params, true)
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    local location = self:locator(params)
    local send_to = format("%s_bulk", location)
    return self:sendToES({send_to=send_to, postfields=params.data})
end


function elasticsearch:sendToES(params)
    if (self.enabled == 0) then
        local message = "elasticsearch not enabled"
        return response:status(404):send({error={message=message,status=404}})
    end
    if (not params.send_to) then
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    if (params.form) and (params.postfields) then
        return errors:wrap(errors.REQUEST_PARAMS_ERROR)
    end

    local info = {}
    info.url = params.send_to
    info.method = params.method or "GET"
    info.form = params.form
    info.json = true

    if (params.postfields) then
        info.postfields = params.postfields
        info.method = nil
    else
        if (info.method == "POST") then

            -- send empty table as an array
            info.postfields = commonlib.Json.Encode(info.form, true)
        end
    end

    System.os.GetUrl(info, resume)
    local err, result = yield()

    self:errors_logger(err, result, info)
    return errors:wrap(err, result)
end


function elasticsearch:errors_logger(err, result, info)
    local code = err or 200
    local result = result or {}
    local rcode = result.rcode or 200
    result.data = result.data or {}
    local items = result.data.items or {}

    if (code >= 400) or (code < 200) or (rcode >= 400) or (rcode < 200) then

        local error_info = {
            flag = "elasticsearch_return_error",
            err = err,
            data = result,
            info = info
        }

        log(error_info, true)
    end


    if (#items > 0) then
        local error_list = {}
        for i, item in ipairs(items) do
            if (item.index.status >= 400) or (item.index.status < 200) then
                item.flag = "elasticsearch_bulk_error"
                table.insert(error_list, item)
            end
        end

        log(error_list, true)
    end
end