<?npl
--[[
Title: pages
Author: ZhengJiabiao
Date: 2018/1
Desc: pages of a website
]]


include_once("./abstract/base.page")
include_once("./elasticsearch.page")
include_once("./validators.page")
include_once("./pages_stars.page")
include_once("./website.page")
include_once("./tags.page")
include_once("./user_tags.page")


local pages = inherit(models.abstract.base, gettable("models.pages"))
pages.db_name = "pages"
local validators = models.validators:new()
local es = models.elasticsearch:new()
local index = CURRENT_ENV .. "_kw_pages"
es:connect({index=index})


function pages:ctor()
    self:addfield("url", "string", true) -- /user/site/page
    self:addfield("siteUrl", "string", false) -- /user/site
    self:addfield("visitCount", "number", false)
    self:addfield("tags", "table", false, 5)
end


function pages:api_insert(params)
    ensureAuthenticated()
    local page, is_params_error, message = self:insert_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    self:db():insertOne({["+url"] = {page.url}}, page, resume)
    local err, result = yield()
    if (result) then
        params.id = result._id
        self:insert_to_es(params)
        result = {url = result.url, tags = result.tags or {}}
        self:save_tags_for_analysis(result)
    end
    return errors:wrap(err, result)
end


function pages:insert_validator(params)
    local clean_data = {}
    local required_fields = {"url"}
    local fields_length = {tags = 5}
    local are_they_sensitive_fields = {"tags"}
    local index_fields_and_model_instance = {
        index_fields = {"url"},
        model_instance = self
    }
    local validate_tasks = {
        {
            validator = validators.required_fields_validator,
            condition = required_fields
        }, {
            validator = validators.fields_length_validator,
            condition = fields_length
        }, {
            validator = validators.sensitive_words_validator,
            condition = are_they_sensitive_fields
        }, {
            validator = validators.existence_validator,
            condition = index_fields_and_model_instance
        },
    }
    validators:add_validate_tasks(validate_tasks, params)
    local is_params_error, message = validators:get_validate_result()

    if (not is_params_error) then
        clean_data = {
            url = params.url,
            tags = params.tags,
            siteUrl = self:get_site_url(params),
        }
    end
    return clean_data, is_params_error, message
end


function pages:get_site_url(params)
    local site_url
    local username, sitename
    if (not params.username) and (params.url) then
        username, sitename = self:get_username_and_sitename(params.url)
    else
        username, sitename = params.username, params.sitename
    end
    site_url = "/" .. username
    if (sitename) then site_url = site_url .. "/" .. sitename end
    return site_url
end


function pages:get_username_and_sitename(url)
    local splited_url = commonlib.split(url, "/")
    return splited_url[1], splited_url[2]
end


function pages:api_updateTags(params)
    if (params.url) then
        self:db():findOne({["+url"]={params.url}}, resume)
        local err, result = yield()
        if (not result) then return self:api_insert(params) end
    end

    ensureAuthenticated()
    local page, is_params_error, message = self:update_tags_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    self:db():updateOne({["+url"] = {page.url}}, {tags = page.tags}, resume)
    local err, result = yield()
    if (result) then
        params.id = result._id
        self:update_to_es(params)
        result = {url = result.url, tags = result.tags or {}}
        self:save_tags_for_analysis(result)
    end
    return errors:wrap(err, result)
end


function pages:update_tags_validator(params)
    local clean_data = {}
    local required_fields = {"url", "tags"}
    local are_they_sensitive_fields = {"tags"}
    local fields_length = {tags = 5}
    local validate_tasks = {
        {
            validator = validators.required_fields_validator,
            condition = required_fields
        }, {
            validator = validators.sensitive_words_validator,
            condition = are_they_sensitive_fields
        }, {
            validator = validators.fields_length_validator,
            condition = fields_length
        },
    }
    validators:add_validate_tasks(validate_tasks, params)
    local is_params_error, message = validators:get_validate_result()

    if (not is_params_error) then
        clean_data = {
            url = params.url,
            tags = params.tags,
        }
    end
    return clean_data, is_params_error, message
end


function pages:save_tags_for_analysis(params)
    local tags_model = models.tags:new()
    local user_tags_model = models.user_tags:new()
    tags_model:insert(params)
    user_tags_model:insert(params)
end


function pages:api_updateContent(params)
    if (params.url) then
        self:db():findOne({["+url"]={params.url}}, resume)
        local err, result = yield()
        if (not result) then
            return self:api_insert(params)
        else
            params.id = result._id
        end
    end

    -- ensureAuthenticated()
    local page, is_params_error, message = self:update_content_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    self:update_to_es(page)
    return errors:wrap(nil)
end


function pages:update_content_validator(params)
    local clean_data = {}
    local required_fields = {"url", "content"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (not is_params_error) then
        clean_data = {
            id = params.id,
            url = params.url,
            content = params.content,
        }
    end
    return clean_data, is_params_error, message
end


function pages:api_star(params)
    ensureAuthenticated()
    local stars = models.pages_stars:new()
    return stars:star(params)
end


function pages:updateVisitCount(params)
    local required_fields = {"url"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    local page = {url = params.url}
    self:db():findOne({["+url"]={page.url}}, resume)
    local err, result = yield()
    if (result) then
        visitCount = (result.visitCount or 0) + 1
        self:db():updateOne({["+url"] = {page.url}}, {visitCount = visitCount}, resume)
        err, result = yield()
    else
        page.visitCount = 1
        page.siteUrl = self:get_site_url(params)
        self:db():insertOne({["+url"] = {page.url}}, page, resume)
        err, result = yield()
        if (result) then
            page.id = result._id
            self:insert_to_es(page)
        end
    end
    result = {visitCount = result.visitCount}
    return errors:wrap(err, result)
end


function pages:api_getDetail(params)
    local required_fields = {"url", "visitor"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    local page = {url = params.url, visitor = params.visitor}
    self:db():findOne({["+url"] = {page.url}}, resume)
    local err, result = yield()
    result = result or {}
    local stars = models.pages_stars:new()
    local starredCount_and_starred = stars:get_starred_count_of_a_page(page)
    result = {
        url = page.url,
        starredCount = starredCount_and_starred.starredCount,
        starred = starredCount_and_starred.starred,
        tags = result.tags or {},
        visitCount = result.visitCount or 0,
    }
    return errors:wrap(err, result)
end


function pages:api_delete(params)
    ensureAuthenticated()
    local page, is_params_error, message = self:delete_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    self:db():findOne({["+url"] = {page.url}}, resume)
    local err, result = yield()
    if (result) then
        params.id = result._id
        local stars = models.pages_stars:new()
        local err, result = stars:delete_page(page)
        if (not err) then
            self:delete_in_es(params)
            self:db():deleteOne({url = page.url}, resume)
            err, result = yield()
        end
    end
    return errors:wrap(err, result)
end


function pages:delete_validator(params)
    local clean_data = {}
    local required_fields = {"url"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (not is_params_error) then clean_data = {url = params.url} end
    return clean_data, is_params_error, message
end


function pages:delete_website(params)
    -- ensureAuthenticated()
    local site, is_params_error, message = self:delete_website_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    local siteUrl = self:get_site_url(params)
    local stars = models.pages_stars:new()
    local err, result = stars:delete_website({siteUrl = siteUrl})
    self:db():find({_id={gt=0, limit=100000}, siteUrl= siteUrl}, resume)
    local err, pages = yield()
    if (not err) then
        self:db():delete({siteUrl = siteUrl}, resume)
        err, result = yield()
        self:delet_website_in_es(pages)
    end
    return err, result
end


function pages:delete_website_validator(params)
    local clean_data = {}
    local required_fields = {"username", "sitename"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (not is_params_error) then
        clean_data = {
            username = params.username,
            sitename = params.sitename,
        }
    end
    return clean_data, is_params_error, message
end


function pages:insert_to_es(params)
    local username, sitename = self:get_username_and_sitename(params.url)
    local website_model = models.website:new()
    params.visibility = "public"

    if (sitename) then
        website_model:db():findOne({["+username+sitename"] = {username, sitename}}, resume)
        local err, site = yield()
        if (site) then params.visibility = site.visibility or "public" end
    end

    local page = {
        type = "pages",
        id = params.id,
        username = username,
        sitename = sitename,
        url = params.url,
        tags = params.tags or {},
        content = self:md_to_string(params.content) or "",
        update_time = datetime(),
        visibility = params.visibility,
    }

    if (page.sitename) then
        page.pagename = string.gsub(page.url, format("/%s/%s/", page.username, page.sitename), "")
        page.pagetype = "normal"
    else
        page.pagetype = "profile"
    end

    es:insertOne(page, function(err, data) end)
end


function pages:update_to_es(params)
    local username, sitename = self:get_username_and_sitename(params.url)
    local website_model = models.website:new()
    params.visibility = "public"

    if (sitename) then
        website_model:db():findOne({["+username+sitename"] = {username, sitename}}, resume)
        local err, site = yield()
        if (site) then params.visibility = site.visibility or "public" end
    end

    local page = {
        type = "pages",
        id = params.id,
        tags = params.tags,
        content = self:md_to_string(params.content),
        update_time = datetime(),
        visibility = params.visibility,
    }

    es:updateOne(page, function(err, data) end)
end


function pages:md_to_string(content)
    return content
end


function pages:delete_in_es(params)
    local page = {
        type = "pages",
        id = params.id,
    }
    es:deleteOne(page, function(err, data) end)
end


function pages:delet_website_in_es(pages)
    local bulk_data = ""
    for i, page in ipairs(pages) do
        bulk_data = bulk_data .. format('{"delete":{"_id":"%d"}}', page._id) .. "\n"
    end
    return es:bulk({data = bulk_data, type = "pages"}, function(err, data) end)
end


function pages:api_search(params)
    local clean_params, is_params_error, message = self:search_validator(params)
    if (is_params_error) then
        return response:status(400):send({error={message=message,status=400}})
    end
    local err, search_result = es:search(clean_params)
    local rcode = search_result.rcode
    local wrapped_result = {}
    if (rcode == 200) then
        wrapped_result = self:wrap_search_result(search_result)
    else
        wrapped_result = search_result.data
    end
    return errors:wrap(err, wrapped_result)
end


function pages:search_validator(params)
    local clean_data = {}
    local required_fields = {"q"}
    local is_params_error, message = validators.required_fields_validator(params, required_fields)
    if (not is_params_error) then
        clean_data = {
            type = "pages",
            q = params.q,
            fields = {'tags', 'content', 'username', 'sitename', 'pagename'},
            page = tonumber(params.page) or 1,
            size = tonumber(params.size) or 500,
            sort = params.sort,
            highlight = tonumber(params.highlight) or 1,
            pre_tags = {"<span>"},
            post_tags = {"</span>"},
            fuzziness = "AUTO",
        }
        if (clean_data.size > 500) then clean_data.size = 500 end
    end
    return clean_data, is_params_error, message
end


function pages:wrap_search_result(result)
    local wrapped_result = {}
    local rcode = result.rcode

    wrapped_result = {
        timed_out = result.data.timed_out,
        took = result.data.took,
        total = result.data.hits.total,
        status = rcode
    }

    local hits = {}
    for i, hit in ipairs(result.data.hits.hits) do
        if (hit._source.visibility ~= "private") then
            hit._source.highlight = hit.highlight
        else
            hit._source.tags = {}
        end
        hit._source.content = nil
        hits[#hits + 1] = hit._source
    end

    wrapped_result.hits = hits
    return wrapped_result
end

